"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSandboxRuntimeAPI = exports.getNodeRuntimeAPI = exports.addMagicAgent = exports.fetchProduct = void 0;
const tslib_1 = require("tslib");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const _1 = require(".");
const polyfill_response_1 = require("./polyfill-response");
const errors_1 = require("./errors");
function fetchProduct(args) {
    return async (path, init) => {
        const url = productURL(args.remote, path);
        init = (0, exports.addMagicAgent)(init);
        init.headers = Object.assign(Object.assign({}, init.headers), { authorization: `Forge ${args.provider}` });
        const response = await (0, node_fetch_1.default)(url, init);
        handleProxyResponseErrors(response);
        return response;
    };
}
exports.fetchProduct = fetchProduct;
const ATLASSIAN_TOKEN_SERVICE_KEY = 'atlassian-token-service-key';
const handleProxyResponseErrors = (response) => {
    if (response.headers.has('forge-proxy-error')) {
        const errorReason = response.headers.get('forge-proxy-error');
        if (errorReason === 'NEEDS_AUTHENTICATION_ERR') {
            throw new errors_1.NeedsAuthenticationError('Authentication Required', ATLASSIAN_TOKEN_SERVICE_KEY);
        }
        throw new errors_1.ProxyRequestError(response.status, response.headers.get('forge-proxy-error'));
    }
};
function productURL(remote, path) {
    if (!path.startsWith('/')) {
        path = '/' + path;
    }
    return `https://${remote}${path}`;
}
const addMagicAgent = (init) => (Object.assign(Object.assign({}, init), { agent: 'FORGE_PRODUCT_REQUEST' }));
exports.addMagicAgent = addMagicAgent;
const throwNotImplementedError = () => {
    throw new Error('not implemented');
};
function getNodeRuntimeAPI() {
    return {
        fetch: (0, _1.wrapWithRouteUnwrapper)(node_fetch_1.default),
        requestJira: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'none', remote: 'jira' })),
        requestConfluence: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'none', remote: 'confluence' })),
        requestBitbucket: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'none', remote: 'bitbucket' })),
        asUser: () => ({
            requestJira: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'user', remote: 'jira' })),
            requestConfluence: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'user', remote: 'confluence' })),
            requestBitbucket: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'user', remote: 'bitbucket' })),
            requestGraph: (0, _1.wrapRequestGraph)(fetchProduct({ provider: 'user', remote: 'stargate' })),
            withProvider: throwNotImplementedError
        }),
        asApp: () => ({
            requestJira: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'app', remote: 'jira' })),
            requestConfluence: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'app', remote: 'confluence' })),
            requestBitbucket: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'app', remote: 'bitbucket' })),
            requestGraph: (0, _1.wrapRequestGraph)(fetchProduct({ provider: 'app', remote: 'stargate' }))
        })
    };
}
exports.getNodeRuntimeAPI = getNodeRuntimeAPI;
function getSandboxRuntimeAPI(api) {
    return (0, _1.wrapFetchApiMethods)(api, polyfill_response_1.transformResponse);
}
exports.getSandboxRuntimeAPI = getSandboxRuntimeAPI;
