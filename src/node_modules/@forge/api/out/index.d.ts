import { RequestInit, Response } from 'node-fetch';
import { QueryApi, EntityStorageApi } from '@forge/storage';
import { authorize } from './authorization';
import { Route } from './safeUrl';
import { webTrigger } from './webTrigger';
import { createRequestStargateAsApp } from './runtime/fetch-and-storage';
export type APIResponse = Pick<Response, 'json' | 'text' | 'arrayBuffer' | 'ok' | 'status' | 'statusText' | 'headers'>;
export type FetchMethod = (url: string, init?: RequestInit) => Promise<APIResponse>;
export type FetchMethodAllowingRoute = (url: string | Route, init?: RequestInit) => Promise<APIResponse>;
export type RequestProductMethod = (url: Route, init?: RequestInit) => Promise<APIResponse>;
export type FetchOptions = RequestInit;
export interface RequestProductMethods {
    requestJira: RequestProductMethod;
    requestConfluence: RequestProductMethod;
    requestBitbucket: RequestProductMethod;
}
export interface GraphQLFetchMethods {
    requestGraph: (query: string, variables?: any, headers?: Record<string, any>) => Promise<APIResponse>;
}
export interface ExternalAuthFetchMethods {
    hasCredentials: () => Promise<boolean>;
    requestCredentials: () => Promise<boolean>;
    listCredentials: () => Promise<string[]>;
    fetch: FetchMethodAllowingRoute;
}
export interface ExternalAuthFetchMethodsProvider {
    withProvider: (provider: string, remoteName?: string, tokenId?: string) => ExternalAuthFetchMethods;
}
export interface StorageMethods {
    get: (key: string) => Promise<any>;
    set: (key: string, value: any) => Promise<void>;
    delete: (key: string) => Promise<void>;
}
export interface PropertiesAPI {
    onJiraProject: (context: string) => StorageMethods;
    onJiraIssue: (context: string) => StorageMethods;
    onConfluencePage: (context: string) => StorageMethods;
    onConfluenceSpace: (context: string) => StorageMethods;
}
export interface StorageAPI extends StorageMethods, QueryApi, EntityStorageApi {
}
export interface ForgeStorageAPI extends StorageAPI {
    getSecret: (key: string) => Promise<any>;
    setSecret: (key: string, value: any) => Promise<void>;
    deleteSecret: (key: string) => Promise<void>;
}
export interface StoreAPI extends PropertiesAPI {
    onJiraProject: (context: string) => StorageMethods;
    onJiraIssue: (context: string) => StorageMethods;
    onConfluencePage: (context: string) => StorageMethods;
    onConfluenceSpace: (context: string) => StorageMethods;
}
export interface FetchAPI extends RequestProductMethods {
    asUser(): RequestProductMethods & GraphQLFetchMethods & ExternalAuthFetchMethodsProvider;
    asApp(): RequestProductMethods & GraphQLFetchMethods;
    fetch: FetchMethodAllowingRoute;
}
export interface ForgeAPI extends FetchAPI {
    store: StoreAPI;
}
declare const asUser: () => RequestProductMethods & GraphQLFetchMethods & ExternalAuthFetchMethodsProvider;
declare const asApp: () => RequestProductMethods & GraphQLFetchMethods;
declare const fetch: FetchMethodAllowingRoute;
declare const requestJira: RequestProductMethod;
declare const requestConfluence: RequestProductMethod;
declare const requestBitbucket: RequestProductMethod;
declare const store: PropertiesAPI;
declare const storage: ForgeStorageAPI;
declare const properties: PropertiesAPI;
declare const API: ForgeAPI;
export declare const privacy: {
    reportPersonalData: (accounts: import("./privacy").Account[]) => Promise<import("./privacy").AccountUpdate[]>;
};
export default API;
export { asUser, asApp, authorize, fetch, requestJira, requestConfluence, requestBitbucket, store, storage, properties, webTrigger, createRequestStargateAsApp };
export { QueryBuilder, QueryApi, EntityStorageApi, Condition, ListResult, Predicate, Result, Value, WherePredicate, FilterPredicate, startsWith, WhereConditions, FilterConditions, SortOrder } from '@forge/storage';
export { route, assumeTrustedRoute, routeFromAbsolute, Route } from './safeUrl';
export { ForgeRuntime, getRuntime } from './api/runtime';
export { NeedsAuthenticationError, ProxyRequestError, FetchError, ExternalEndpointNotAllowedError, ProductEndpointNotAllowedError, RequestProductNotAllowedError, NotAllowedError, InvalidWorkspaceRequestedError, HttpError, FUNCTION_ERR, isForgePlatformError, isHostedCodeError } from './api/errors';
//# sourceMappingURL=index.d.ts.map